# To locally run OHIF
APP_CONFIG=config/cs.js yarn run dev

this file referenced by APP_CONFIG is `./platform/viewer/public/config/cs.js`

# Notes to understand the OHIF viewer.
Inside ./platform/i18n is the text information, `locales` dependent.
Here one can change wording of the different texts around.

# ./extensions/vtk
Contains OHIFVTKViewport. This wraps the react-vtkjs-viewport. 
Contains commands related to MPR.

# ./node_modules/react-vtkjs-viewport
Related. 

# node_modules/vtk.js
All vtk routines come to here. This is the point of entry to use vtk.

# ./platform/viewer
Apparently, contains the entry-point to the viewer? Unclear.
There is `./platform/viewer/src/head.html` that contains the head tag 
of the application. Particularly, the "title" value.

There is also `./platform/viewer/src/App.js` which loads apparently many modules
and points to a "cornerstone".

# ./platform/core
`./platform/core/src/cornerstone.js` apparently does not much, just import from
`./platform/core/src/classes/MetadataProvider.js`.

# ./platform/cpre/src/classes/MetadataProvider.js
Here there are more imports. The important one is
 `import dicomParser from 'dicom-parser'`. 
The file provides `class MetadataProvider`.  

There is a lot to unwrap from here. There is an important import 
`import dcmjs from 'dcmjs'`.
Going to `./node_modules/dcmjs` leads to an open-source project for DICOM
manipulation. It focuses in Enhanced Multiframe Images, Segmentation Objects,
Parametric Maps, Structured reports.

This class apparently just reads certain values. But do not handles what is 
being presented in the viewer. The main suspect is the named `cornerstone`.

# ./node_modules/cornertone-core
README.md -> "delivers a complete web based medical imaging platform."
"Cornerstone Core itself has no ability to read/parse or load images and 
instead depends on one or more ImageLoadres to function".

References to `CornerstoneWADOImageLoader` as an image loader.
The API to interface to with the cornerstone `CornerstoneTools`.
Key features->"API support for changing viewport properties (e.g. ww/wc, zoom, pan, invert)"

# ./node_modules/cornerstone-tools
README.md -> "[...] and leverages DICOM metadata (when available) for advanced
functionality"
Apparently, nowhere in the README makes any mention to MPR or so.

# ./node_modues/cornerstone-wado-image-loader
unclear

# ./node_modules/react-cornerstone-viewport
Found this in an example in the repository.
```
  import dicomParser from 'dicom-parser';
  import cornerstone from 'cornerstone-core';

  cornerstoneWADOImageLoader.external.cornerstone = cornerstone;
  cornerstoneWADOImageLoader.external.dicomParser = dicomParser;
```

I found in
# ./platform/core/src/classes/StudyLoadingListener.js
```
import cornerstone from 'cornerstone-core';
  [...]
  _checkCachedData() {
    const dataSet = cornerstoneWADOImageLoader.wadouri.dataSetCacheManager.get(
      this._dataSetUrl
    );
  [...]
```
Also some functions regarding caching, tha use cornerstone functions.
```
cornerstone.events.addEventListener
cornerstone.events.removeEventListener
const image = cornerstone.imageCache.imageCache[imageId];
const imageObject = cornerstone.imageCache.getImageLoadObject(imageId);
return `${cornerstone.EVENTS.IMAGE_LOADED}.${this.id}`;
return `${cornerstone.EVENTS.IMAGE_CACHE_PROMISE_REMOVED}.${this.id}`;
```

similar calls in
# ./studies/services/wado/studyInstanceHelpers.js
# ./studies/services/wado/studyInstanceHelpers.js
# ./classes/StudyLoadingListener.js
# ./studies/services/qido/instances.js
# ./utils/dicomLoaderService.js

There are similar calls inside other javascripts inside `# ./platform/viewer`

# ./platform/ui/src/viewer/Toolbar.js
Has apparent information regarding the buttons of the toolbar.
But these buttons do not include the MPR

# ./platform/viewer/src/connectedComponents/Viewer.js
I'm here currently, following the error message for the reload "grep ToolbarRow"

Searching for the error generated by the Toolbar, investigated `ErrorBoundaryDialog`,
that seems to only be a "tag function", that is, a tag, that given
certain class properties, unwraps into some much complex set of tags.

Apparently, the error gets triggered by some property definitions. Leading me
to investigate `import PropTypes from 'prop-types'`.
# ./platform/ui/node_modules/prop-types
"Runtime type checking for React props and similar objects
You can use prop-types to document the intended types of properties passed to
components. React will check props passed to your components against those
definitions, and warn in development if they don't match. 
"

Coming back to the `Viewer extends Component` class, there are many properties
that are set.
The Viewer contains an:
  - studies: array of shape with StudyInstanceUId, date, patientId and 
     - displaySets: which is an array with:
        displaySetInstanceUID (required), SeriesDescription, SeriesNumber, 
        InstanceNumber, numImageFrames, Modality (required), images (and array
           of getImageId, a required function)).
    TODO: understand what is the displaySets array. 
  - studyInstanceUIDs, array.
  [...]
  - viewports: PropTypes.object (required)
  - activeViewportIndex: number (required)
    TODO: understand these viewport objects
  - isStudyLoaded: boolean
  - dialog: object

TODO: Understand constructor syntax. Particularly
```
const { activeServer } = this.props;
const server = Object.assign({}, activeServer);
const external = { servicesManager };

[...]

this._getActiveViewport = this._getActiveViewport.bind(this);
# what is happening here? This member does not exist in principle.
```
ans: There is no need of forward declaration, these are calls to member functions
```
  _getActiveViewport() {
    return this.props.viewports[this.props.activeViewportIndex];
  }
```
So aparently, it will the the active viewport Index, which is a number, and then
select a particular viewport object, which should have been loaded earlier.
I still don't understand what is the `.bind(this)` part. TODO.

Other syntactically weirdness
`const PatientID = studies[0] && studies[0].PatientID;`

Most misterious thing. I don't see anywhere in this file where the `viewports` 
are defined.

Not found in `MeasurementApi` class, therefore `MeasurementApi.setConfiguration`
not to bla.e The same for the `TimepointApi.setConfiguration` function.

# ./platform/ui/src/components/toolbarSection/ToolbarSection.js

Appears to define the "ToolbarSection" class, which has as props an array of
buttons, and an array of ids of the buttons that should be shown active.
Potential candidate.
```
render (){
[...]
              isActive={this.props.activeButtons.includes(button.id)}
[...]
}
```
TODO: Check this label in the generated html file.

TODO: This `ToolbarSection` class is not elsewhere in the code, just 
"re-exported" by some `index.js` file that just imports a bunch of things
and then export everythig else. Very strange, as I do not find an use to it.

# ./extensions/vtk/src/toolbarComponents/VTKMPRToolbarButton.js
```
[...]
let isVisible = true;
[...]
isVisible = _isDisplaySetReconstructable( viewportSpecificData, 
                                          activeViewportIndex,);

const _isDisplaySetReconstructable = (viewportSpecificData = {}, activeViewportIndex) => {
  if (!viewportSpecificData[activeViewportIndex]) {
  return false;
  };

  const { displaySetInstanceUID, StudyInstanceUID } = viewportSpecificData[
  activeViewportIndex
  ];

const studies = studyMetadataManager.all();

const study = studies.find(
study => study.studyInstanceUID === StudyInstanceUID
);

if (!study) {
return false;
}

const displaySet = study._displaySets.find(set => set.displaySetInstanceUID === displaySetInstanceUID);

if (!displaySet) {
return false;
};

return displaySet.isReconstructable;
};
```
There is the `studyMetadataManager` object, which gives all the studies.
Then, searches for the study that has the same study instance UID.
Then, gets the displaySet that contains a set whose `displaySetInstanceUID` 
matches the given one. 
ultimately, returns the displaySet.isReconstructable value. 

TODO: find out what a displaySet is and who sets if it is reconstructable

# ./platform/core/src/utils/studyMetadataManager.js  
Defines a simple container that has as member functions `add, remove, ...`
It seems that the container defines some sort of class that can be 
accessed anywhere in the codebase? Every use I find apparently adds 
the metadata directy to the imported class.

# ./platform/core/src/classes/metadata/Metadata.js
defines a simple class constructed from some "data" and "id". It also allows
to define new members, but that's more or less it.
These members contain information to make them writable, configurable or 
enumerable. Seems like a general construct.

Constaints the method
`getData()   { return this._data; }` which returns the holded data.

# ./platform/core/src/classes/metadata/StudyMetadata.js
extends Metadata.js
defines new properties:
- _studyInstanceUID
- _series
- _displaySets [_!]

The displaySets is defined as
`        value: this.getData().displaySets ? this.getData().displaySets : [],`

So it inherits the displaySets property from within the data that is being
set. 

### New attempt

going back at `VTKMPRToolbarButton.js`, I placed some console.log calls 
to understand the issue.
The "isVisible" variable is set to false by the function 
`_isDisplaySetReconstructable`,
this one, output `displaySet.isReconstructable`, which is false.

`displaySet = study._displaySets.find ... `

We apparently get all the studies. Then from those, we filter those with the
same study UID, and from those, we search in the 
`_displaySets` field, if anything 

Apparently, the `displaySets`, is an array created by OHIF, with fields as:
"isMultiFrame", "isReconstructable", "reconstructionIssues", etc. 
These have their own UID.

Everything is drawn from the `studyMetadataManager.all()`.
```
const studyMetadataList = new TypeSafeCollection();
...
function all(options) {
  return studyMetadataList.all(options);
}
```

# ./platform/core/src/classes/TypeSafeCollection.js
Appears to be a general purpose class, to append fields?

Apparently, the `studyMetadataManager` is set in multiple places around the
codebase. Hunting for these we find

# ./platform/core/src/classes/OHIFStudyMetadataSource.js 
# ./platform/core/src/routes/StandaloneRouting.js
appears to not be called.

Here is the studyMetadata added, with the respective fields
# ./platform/viewer/src/connectedComponents/ViewerRetrieveStudyData.js


Traced to `_updateStudyMetadataManager(study, studyMetadata)` in here.

Right before, there is a call to `_updateStudyDisplaySets`. 

Apparently, these already had set the `displaySets` field.
` const studyMetadata = new OHIFStudyMetadata(
study, study.StudyInstanceUID);`

# ./platform/core/src/classes/metadata/OHIFStudyMetadata.js

This class inherits from `StudyMetadata`, including an init file.
The init file apparently just gies the same studyInstanceUID field to all the 
series in the study?

# ./platform/core/src/classes/metadata/StudyMetadata.js
` class StudyMetadata extends Metadata `
Inherits from Metadata

This StudyMetadata include a `_displaySets` field. This apparently populates 
with the `displaySets` that already comes from Metadata.

# ./platform/core/src/classes/metadata/Metadata.js
Apparently, just adds the properties `_data`, `_uid`, `_custom`.

let's backtrack. Inside `OHIFStudyMetadata.js` there is a call to add series
with OHIFSeriesMetadata.

# ./platform/core/src/classes/metadata/OHIFSeriesMetadata.js 
These appear to be part of the studyMetadata, under the `_series` field.

Change of plan, I recognize that the displaySets is an array of `ImageSet` classes.
Let's grep that

# platform/more/src/classes/ImageSet.js
Appears to just be a holder class for properties.

Going back to StudyMetadata, found the function
`isDisplaySetReconstructable(instances)` in

# platform/core/src/utils/isDisplaySetReconstructable.js
/* Checks if a series is reconstructable to a 3D volume*/

Leaving sometraces, the code leads to the function
`constructableModalities.includes(Modality)` 

which is defined a bit below as 
`const constructableModalities = ['MR', 'CT', 'PT', 'NM'];`

DONE

##############################################################################

Overlapping segmentations are not being rendered. Could this be fixed?

grep error message `Overlapping Segmentation Found`
leads to
# ./extensions/vtk/src/OHIFVTKViewport.js

The error message comes from the function
`getViewportData`







